var documenterSearchIndex = {"docs":
[{"location":"manual/#Manual-1","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"SignalOperators is composed of a set of functions for generating, inspecting and operating over signals. Here, a \"signal\" is represented as a number of channels (e.g. left and right speaker) with values (e.g. Float64) sampled regularly in time (e.g. every 100th of a second, or 100 Hz).","category":"page"},{"location":"manual/#Key-concepts-1","page":"Manual","title":"Key concepts","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are several important concepts employed across the public interface. Let's step through one of the examples from the homepage (and README.md), which demonstrates most of these concepts. ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sound1 = signal(sin,ω=1kHz) |> until(5s) |> ramp |> normpower |> amplify(-20dB)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"This example creates a 1 kHz pure-tone (sine wave) that lasts 5 seconds. Its amplitude is 20 dB lower than a signal with unit 1 power. ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are a few things going on here: piping, the use of units, infinite length signals, and unspecified sample rates.","category":"page"},{"location":"manual/#Piping-1","page":"Manual","title":"Piping","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Almost all of the functions implemented in SignalOperators can be piped. This means that instead of passing the first argument that function, you can pipe it using |>. For example, the two statements below have the same meaning. ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sound1 = signal(sin,ω=1kHz) |> until(5s)\nsound1 = until(signal(sin,ω=1kHz),5s)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The use of piping makes it easier to read the sequence of operations that are performed on the signal.","category":"page"},{"location":"manual/#Units-1","page":"Manual","title":"Units","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"In any place where a function needs a time or a frequency, it can be specified in appropriate units. There are many places where units can be passed. They all have a default assumed unit, if a plain number, without units, is passed. The default units are seconds, Hertz, and radians as appropriate for the given argument.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sound1 = signal(sin,ω=1kHz)\nsound1 = signal(sin,ω=1000)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Each unit is represented by a constant you can multiply by a number (in Julia, 10ms == 10*ms). To make use of the unit constants, you must call using SignalOperators.Units. This exports the following units: samples, ksamples, Hz, kHz s, ms, rad, °, and dB. You can just include the ones you want using e.g. using SignalOperators.Units: Hz, or you can include more by adding the Unitful package to your project and adding the desired units from there. For example, using Unitful: MHz would include mega-Hertz frequencies (not usually useful for signals that are sounds). Most of the default units have been re-exported from Unitful. However, the samples unit and its derivatives (e.g. ksamples) are unique  to the SignalOperators package and allows you to specify the time in terms of the number of samples: e.g. at a sample rate of 100 Hz, 2s == 200samples. Other powers of ten are represented for samples, (e.g. Msamples for mega-samples) but they are not exported (e.g. you would have to call SignalOperators.Units: Msamples before using 20Msamples). ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"note: Note\nYou can find the available powers-of-ten for units in Unitful.prefixdict","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Note that the output of functions to inspect a signal (e.g. duration, samplerate) are bare values in the default unit (e.g. seconds or Hertz). No unit is explicitly provided by the return value.","category":"page"},{"location":"manual/#Decibels-1","page":"Manual","title":"Decibels","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can pass an amplification value as a unitless or a unitful value in dB; a unitless value is not assumed to be in decibels. Instead, it's assumed to be the actual ratio by which you wish to multiply the signal. E.g. amplify(x,2) will make x twice as loud. ","category":"page"},{"location":"manual/#Infinite-lengths-1","page":"Manual","title":"Infinite lengths","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Some of the ways you can define a signal lead to an infinite length signal. You cannot store an infinite signal. It is represented as a function of some kind. Operations on signals are generally lazy, meaning the samples of the signal aren't computed until necessary. To allow actual data to be created from a signal, you have to specify the length, using until. For example, when using signal(sin), the signal is an infinite length sine wave. That's why, in the example above we use until to specify the length, like so: ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"signal(sin,ω=1kHz) |> until(5s)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Infinite lengths are represented as the value inflen. This has overloaded definitions of various operators to play nicely with ordering, arithmetic etc... ","category":"page"},{"location":"manual/#Unspecified-sample-rates-1","page":"Manual","title":"Unspecified sample rates","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You may notice that the above signal has no defined sample rate. Such a signal is defined by a function, and can be sampled at whatever rate you desire. If you add a signal to the chain of operations that does have a defined sample rate, the unspecified sample rate will be resolved to that same rate (see signal promotion, below). If there is no defined sample rate by the time you call sink, you can specify it then. ","category":"page"},{"location":"manual/#Sinking-1","page":"Manual","title":"Sinking","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Once you have defined a signal, you can create some concrete sequence of samples from it. This is done using sink. The resulting value is, by default, itself a signal. This means you can continue to processes it with more operators. The function sink is also used to create a file. Sink must consume a finite-length signal. To store the five second signal in the above example to \"example.wav\" we could write the following.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sound1 |> sink(\"example.wav\")","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"In this case sound1 had no defined sample rate, so the default sample rate of 44.1khz will be used. The absence of an explicit sample rate will raise a warning.","category":"page"},{"location":"manual/#Signal-promotion-1","page":"Manual","title":"Signal promotion","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A final concept, which is not as obvious from the examples, is the use of automatic signal promotion. When multiple signals are passed to the same operator, and they have a different number of channels, or different sample rate, the signals are first converted to the highest fidelity format and then operated on. This allows for a relatively seamless chain of operations where you don't have to worry about the specific format of the signal, and you won't loose information about your signals unless you explicitly request a lower fidelity signal format (e.g. using tochannels or tosamplerate).","category":"page"},{"location":"manual/#Signal-generation-1","page":"Manual","title":"Signal generation","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are four basic types that can be interpreted as signals: numbers, arrays, functions and files. Internally the function signal is called on any object passed to a function that inspects or operates on a signal; you can call signal yourself if you want to specify more information. For example, you want to provide the exact sample rate the signal should be interpreted to have.","category":"page"},{"location":"manual/#Numbers-1","page":"Manual","title":"Numbers","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A number is treated as an infinite length signal, with unknown sample rate. ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"1 |> until(1s) |> sink(samplerate=10Hz) == ones(10)","category":"page"},{"location":"manual/#Arrays-1","page":"Manual","title":"Arrays","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A standard array is treated as a finite signal, with unknown sample rate.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"rand(10,2) |> sink(samplerate=10Hz) |> duration == 1","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"An AxisArray is treated as a finite signal with a known sample rate (and is the default output of sink) ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"using AxisArrays\nx = AxisArray(rand(10,1),Axis{:time}(range(0,1,length=10)))\nsamplerate(x) == 10","category":"page"},{"location":"manual/#Functions-1","page":"Manual","title":"Functions","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A function can be treated as an infinite signal. It should take a single argument which is the time. This value is in radians if you specify a frequency using ω (or frequency), otherwise the input is in seconds. See signal's documentation for more details.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"signal(sin,ω=1kHz) |> duration |> isinf == true","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A small exception to this is randn. It can be used directly as a signal with unknown sample rate. ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"randn |> duration == isinf","category":"page"},{"location":"manual/#Files-1","page":"Manual","title":"Files","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A file is interpreted as a wav audio file to be loaded into memory. You must include the WAV package for this to work.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"using WAV\nx = signal(\"example.wav\")","category":"page"},{"location":"manual/#Signal-inspection-1","page":"Manual","title":"Signal inspection","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can examine the properties of a signal using nsamples, nchannels, samplerate, and duration.","category":"page"},{"location":"manual/#Signal-operators-1","page":"Manual","title":"Signal operators","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are several categories of signal operators: extending, cutting, filtering, ramping, and mapping.","category":"page"},{"location":"manual/#Extending-1","page":"Manual","title":"Extending","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can extend a signal using pad or append. A padded signal becomes infinite and ends with the specified value, usually one or zero. You can append two or more signals (or prepend) so they occur one after another.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"pad(x,zero) |> duration |> isinf == true\nappend(x,y) |> duration == duration(x) + duration(y)","category":"page"},{"location":"manual/#Cutting-1","page":"Manual","title":"Cutting","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can cut signals apart, removing either the end of the signal (until) or the beginning (after). The operations are exact compliments of one another.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"append(until(x,2s),after(x,2s)) |> nsamples == nsamples(x)","category":"page"},{"location":"manual/#Filtering-1","page":"Manual","title":"Filtering","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can filter signals, removing undesired frequencies using lowpass, highpass, bandpass, bandstop and filtersignal. The latter allows the use of any arbitrary filter defined using DSP. ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"signal(randn) |> lowpass(20Hz)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"warning: Warning\nIf you write using DSP you will have to also write dB = SignalOperators.Units.dB if you want to make use of the proper meaning of dB for SignalOperators: DSP also defines a value for dB.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"An unusual filter is normpower: it computes the root mean squared power of the signal and then normalizes each sample by that value.","category":"page"},{"location":"manual/#Ramping-1","page":"Manual","title":"Ramping","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A ramp allows for smooth transitions from 0 amplitude to the full amplitude of the signal. It is useful for avoid clicks in the onset or offset of a sound. For example, pure-tones are typically ramped when presented.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"signal(sin,ω=2kHz) |> until(5s) |> ramp","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can ramp only the start of a signal (rampon), or the end of it (rampoff) and you can use ramps to create a smooth transition between two signals (fadeto). ","category":"page"},{"location":"manual/#Mapping-1","page":"Manual","title":"Mapping","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Probably the most powerful operator is mapsignal. It works a lot like map but automatically promotes the signals, as with all operators, and it pads the end of the signal appropriately, so different length signals can be combined. The output is always the length of the longest finite-length signal.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"a = signal(sin,ω=2kHz) |> until(2s)\nb = signal(sin,ω=1kHz) |> until(3s)\na_minus_b = mapsignal(-,a,b)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The function mapsignal cannot, itself be piped, due to ambiguity in the arguments, but shortcuts for this function have been provided for addition (mix) and multiplication (amplify), the two most common operations, and these two shortcuts have piped versions available.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"a_plus_b = a |> mix(b)\na_times_b = a |> amplify(b)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can also add or select out channels using addchannel and channel, which are defined in terms of calls to mapsignal. These use a variant of mapsignal where the keyword bychannel is set to false (see mapsignal's documentation for details).","category":"page"},{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Signal-Generation-1","page":"Reference","title":"Signal Generation","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"signal\nsink\nsink!","category":"page"},{"location":"reference/#SignalOperators.signal","page":"Reference","title":"SignalOperators.signal","text":"signal(x,[samplerate])\n\nCoerce x to be a signal, optionally specifying its sample rate (usually in Hz). All signal operators first call signal(x) for each argument. This means you only need to call signal when you want to pass additional arguments to it.\n\nnote: Note\nIf you pipe signal (e.g. myobject |> signal(2kHz)) you must specify the units of the sample rate, if passed. A unitless number is always interpreted as a constant, infinite-length signal (see below).\n\nThe types of objects that can be coerced to signals are as follows.\n\n\n\n\n\nExisting signals\n\nAny existing signal just returns itself from signal. If a sample rate is specified it will be set if x has an unknown sample rate. If it has a known sample rate and doesn't match samplerate(x) an error will be thrown. If you want to change the sample rate of a signal use tosamplerate.\n\n\n\n\n\nNumbers\n\nNumbers can be treated as infinite length, constant signals of unknown sample rate.\n\n\n\n\n\nArrays\n\nArrays can be treated as signals. The first dimension is time, the second channels. \n\nAxisArrays, if they have an axis labeled time and one or zero additional axes, can be treated as a signal. The time dimension must be represented using on object with the step function defined (e.g. any AbstractRange).\n\n\n\n\n\nFunctions\n\nsignal(fn,[samplerate];[ω/frequency],[ϕ/phase])\n\nFunctions can define infinite length signals of known or unknown sample rate. The function fn can either return a number, or, for multi-channel signals, a tuple of values. \n\nThe input to fn is either a phase value or a time value. If passed a frequency (using either the ω or frequency keyword), the input to fn will be a phase value in radians, ranging from 0 to 2π. If no frequency is specified the value passed to fn is the time in seconds. Specifying phase (by the ϕ or phase keyword) will first add that value to the input before passing it to fn. The phase is assumed to be in units of radians (but you can also pass degrees by using ° or a unit of time (e.g. s for seconds)).\n\n\n\n\n\nIf fn == randn no frequency or phase can be specified. Instead there is a single keyword argument, rng, which allows you to specify the random number generator; rng defaults to Random.GLOBAL_RNG.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.sink","page":"Reference","title":"SignalOperators.sink","text":"sink([signal],[to=AxisArray];duration,samplerate)\n\nCreates a given type of object (to) from a signal. By default it is an AxisArray with time as the rows and channels as the columns. If a filename is specified for to, the signal is written to the given file. If given a type (e.g. Array) the signal is written to a value of that type. The sample rate does not need to be specified, it will use either the sample rate of signal or a default sample rate (which raises a warning). \n\nYou can specify a duration or sample rate for the signal when calling sink if it has yet to be defined.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.sink!","page":"Reference","title":"SignalOperators.sink!","text":"sink!(array,x;[samplerate],[offset])\n\nWrite size(array,1) samples of signal x to array, starting from the sample after offset. If no sample rate has been specified for x you can specify it now, using samplerate (it will default to 44.1kHz).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Signal-Inspection-1","page":"Reference","title":"Signal Inspection","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"inflen\nduration\nnsamples\nnchannels\nsamplerate","category":"page"},{"location":"reference/#SignalOperators.inflen","page":"Reference","title":"SignalOperators.inflen","text":"inflen\n\nRepresents an infinite length. Proper overloads are defined to handle  arithmetic and ordering for the infinite value. \n\nMissing values\n\nFor the purposes of SignalOperators missing values are considered to be unknown, but of finite length. For example: inflen * missing == inflen.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#SignalOperators.duration","page":"Reference","title":"SignalOperators.duration","text":"duration(x)\n\nReturn the duration of the signal in seconds, if known. May return missing or inflen. The value missing always denotes a finite, but unknown length.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.nsamples","page":"Reference","title":"SignalOperators.nsamples","text":"nsamples(x)\n\nReturns the number of samples in the signal, if known. May return missing or inflen. The value missing always denotes a finite, but unknown length.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.nchannels","page":"Reference","title":"SignalOperators.nchannels","text":"nchannels(x)\n\nReturns the number of channels in the signal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.samplerate","page":"Reference","title":"SignalOperators.samplerate","text":"samplerate(x)\n\nReturns the sample rate of the signal (in Hertz). May return missing if the  sample rate is unknown.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Reformatting-1","page":"Reference","title":"Reformatting","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"tosamplerate\ntochannels\ntoeltype\nformat\nuniform","category":"page"},{"location":"reference/#SignalOperators.tosamplerate","page":"Reference","title":"SignalOperators.tosamplerate","text":"tosamplerate(x,fs;blocksize)\n\nChange the sample rate of x to the given sample rate fs. Functionally defined signals (e.g. signal(sin)) are resampled exactly: the function is simply called more times to generate more samples. Data-based signals (signal(rand(50,2))) are resampled using filtering. In this case you can use the keyword arugment blocksize to change the analysis window used. See filtersignal for more details.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.tochannels","page":"Reference","title":"SignalOperators.tochannels","text":"tochannels(x,ch)\n\nForce a signal to have ch number of channels, by mixing channels together or broadcasting a single channel over multiple channels.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.format","page":"Reference","title":"SignalOperators.format","text":"format(x,fs,ch)\n\nEfficiently convert both the samplerate (fs) and channels ch of signal x. This selects an optimal ordering for tosamplerate and tochannels to avoid redundant computations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.uniform","page":"Reference","title":"SignalOperators.uniform","text":"uniform(xs;channels=false)\n\nPromote the sample rate (and optionally the number of channels) to be the highest sample rate (and optionally channel count) of the passed value xs, an iterable of signals.\n\nnote: Note\nuniform rarely needs to be called directly. It is called implicitly, within the body of mapsignal for example.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Signal-Manipulation-1","page":"Reference","title":"Signal Manipulation","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"until\nafter\nappend\nprepend\npad\nfiltersignal\nlowpass\nhighpass\nbandpass\nbandstop\nnormpower\nmapsignal\nmix\namplify\naddchannel\nchannel\nrampon\nrampoff\nramp\nfadeto","category":"page"},{"location":"reference/#SignalOperators.until","page":"Reference","title":"SignalOperators.until","text":"until(x,time)\n\nCreate a signal of all samples of x up until and including time.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.after","page":"Reference","title":"SignalOperators.after","text":"after(x,time)\n\nCreate a signal of all samples of x after time.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.append","page":"Reference","title":"SignalOperators.append","text":"append(x,y,rest...)\n\nAppend a series of signals, one after the other.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.prepend","page":"Reference","title":"SignalOperators.prepend","text":"prepend(xs...)\n\nPrepend the series of signals: prepend(xs...) == append(reverse(xs)...).\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.pad","page":"Reference","title":"SignalOperators.pad","text":"pad(x,padding)\n\nCreate a signal that appends an infinite number of values, padding, to x. The value padding can be a number or a function of a type (e.g. zero).\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.filtersignal","page":"Reference","title":"SignalOperators.filtersignal","text":"filtersignal(x,h;[blocksize])\n\nApply the given filter h (from DSP) to signal x. \n\nBlocksize\n\nBlocksize determines the size of the buffer used when computing intermediate values of the filter. It defaults to 4096. It need not normally be adjusted.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.lowpass","page":"Reference","title":"SignalOperators.lowpass","text":"lowpass(x,low;[order=5],[method=Butterworth(order)],[blocksize])\n\nApply a lowpass filter to x at the given cutoff frequency (low).  See filtersignal for details on blocksize.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.highpass","page":"Reference","title":"SignalOperators.highpass","text":"highpass(x,high;[order=5],[method=Butterworth(order)],[blocksize])\n\nApply a highpass filter to x at the given cutoff frequency (low).  See filtersignal for details on blocksize.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.bandpass","page":"Reference","title":"SignalOperators.bandpass","text":"bandpass(x,low,high;[order=5],[method=Butterworth(order)],[blocksize])\n\nApply a bandpass filter to x at the given cutoff frequencies (low and high).  See filtersignal for details on blocksize.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.bandstop","page":"Reference","title":"SignalOperators.bandstop","text":"bandstop(x,low,high;[order=5],[method=Butterworth(order)],[blocksize])\n\nApply a bandstop filter to x at the given cutoff frequencies (low and high).  See filtersignal for details on blocksize.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.normpower","page":"Reference","title":"SignalOperators.normpower","text":"normpower(x)\n\nA signal with normalized power. That is, divide all samples by the root-mean-squared value of the entire signal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.mapsignal","page":"Reference","title":"SignalOperators.mapsignal","text":"mapsignal(fn,arguments...;padding,bychannel)\n\nApply fn across the samples of arguments, producing a signal of the output of fn. Shorter signals are padded to accommodate the longest finite-length signal. The function fn should treat each argument as a single number and return a single number. This operation is broadcast across all channels of the input. It is expected to be a type stable function.\n\nCross-channel functions\n\nThe function is normally broadcast across channels, but if you wish to treat each channel separately you can set bychannel=false. In this case the inputs to fn will be objects supporting getindex (tuples or arrays) of all channel values for a given sample, and fn should return a type-stable tuple value (for a multi-channle or single-channel result) or a number (for a signle-channel result only). For example, the following would swap the left and right channels.\n\nx = rand(10,2)\nswapped = mapsignal(x,bychannel=false) do (left,right)\n    right,left\nend\n\nPadding\n\nPadding determines how samples past the end of shorter signals are reported. The value of padding is passd to pad. Its default value is determined by the value of fn. The default value for the four basic arithmetic operators is their identity (one for * and zero for +). These defaults are set on the basis of fn using default_pad(fn). A fallback implementation of default_pad returns zero.\n\nTo define a new default for a specific function, just create a new method of default_pad(fn)\n\n\nmyfun(x) = 2x + 3\nSignalOperators.default_pad(::typeof(myfun)) = one\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.mix","page":"Reference","title":"SignalOperators.mix","text":"mix(xs...)\n\nSum all signals together, using mapsignal\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.amplify","page":"Reference","title":"SignalOperators.amplify","text":"amplify(xs...)\n\nFind the product, on a per-sample basis, for all signals xs, using mapsignal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.addchannel","page":"Reference","title":"SignalOperators.addchannel","text":"addchannel(xs...)\n\nConcatenate the channels of all signals into one signal with sum(nchannels,xs) channels, using mapsignal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.channel","page":"Reference","title":"SignalOperators.channel","text":"channel(x,n)\n\nSelect channel n of signal x, as a single channel signal, using mapsignal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.rampon","page":"Reference","title":"SignalOperators.rampon","text":"rampon(x,[len=10ms],[fn=x -> sinpi(0.5x)])\n\nRamp the onset of a signal, smoothly transitioning from 0 to full amplitude over the course of len seconds. \n\nThe function determines the shape of the ramp and should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is fn(0) == 0 and fn(1) == 1.\n\nBoth len and fn are optional arguments: either one or both can be specified, though len must occur before fn if present.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.rampoff","page":"Reference","title":"SignalOperators.rampoff","text":"rampoff(x,[len=10ms],[fn=x -> sinpi(0.5x)])\n\nRamp the offset of a signal, smoothly transitioning from frull amplitude to 0 amplitude over the course of len seconds.\n\nThe function should be non-decreasing and should have a domain and range of [0,1]\n\nBoth len and fn are optional arguments: either one or both can be specified, though len must occur before fn if present.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.ramp","page":"Reference","title":"SignalOperators.ramp","text":"ramp(x,[len=10ms],[fn=x -> sinpi(0.5x)])\n\nRamp the onset and offset of a signal, smoothly transitioning from 0 to full amplitude over the course of len seconds at the start and from full to 0 amplitude over the course of len seconds.\n\nThe function determines the shape of the ramp and should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is fn(0) == 0 and fn(1) == 1.\n\nBoth len and fn are optional arguments: either one or both can be specified, though len must occur before fn if present.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.fadeto","page":"Reference","title":"SignalOperators.fadeto","text":"fadeto(x,y,[len=10ms],[fn=x->sinpi(0.5x)])\n\nAppend x to y, with a smooth transition lasting len seconds fading from x to y (so the total length is duration(x) + duration(y) - len).\n\nThis fade is accomplished with a rampoff of x and a rampon for y. fn should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is  fn(0) == 0 and fn(1) == 1.\n\nBoth len and fn are optional arguments: either one or both can be specified, though len must occur before fn if present.\n\n\n\n\n\n","category":"function"},{"location":"#SignalOperators.jl-1","page":"Home","title":"SignalOperators.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"SignalOperators is a Julia package that aims to provide a clean interface for generating and manipulating signals: typically sounds, but any signal regularly sampled in time could be manipulated.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"You can install it in Julia by starting the Pkg prompt (hit ]), and using the add command.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(1.2) pkg> add SignalOperators","category":"page"},{"location":"#","page":"Home","title":"Home","text":"As a preview of functionality, here are some example sound generation routines. You can find more detailed information in the manual and reference.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using SignalOperators\nusing SignalOperators.Units # allows the use of dB, Hz, s etc... as unitful values\n\n# a pure tone 20 dB below a power 1 signal, with on and off ramps (for\n# a smooth onset/offset)\nsound1 = signal(sin,ω=1kHz) |> until(5s) |> ramp |> normpower |> amplify(-20dB)\n\n# a sound defined by a file, matching the overall power to that of sound1\nsound2 = \"example.wav\" |> normpower |> amplify(-20dB)\n\n# a 1kHz sawtooth wave \nsound3 = signal(ϕ -> ϕ/π,ω=1kHz,ϕ=-π) |> ramp |> normpower |> amplify(-20dB)\n\n# a 5 Hz amplitude modulated noise\nsound4 = randn |> \n    amplify(signal(ϕ -> 0.5sin(ϕ) + 0.5,ω=5Hz)) |> \n    until(5s) |> normpower |> amplify(-20dB)\n\n# a 1kHz tone surrounded by a notch noise\nSNR = 5dB\nx = signal(sin,ω=1kHz) |> until(1s) |> ramp |> normpower |> amplify(-20dB + SNR)\ny = signal(randn) |> until(1s) |> bandstop(0.5kHz,2kHz) |> normpower |>\n  amplify(-20dB)\nscene = mix(x,y)\n\n# write all of the signals to a single file, at 44.1 kHz\nappend(sound1,sound2,sound3,sound4,scene) |> tosamplerate(44.1kHz) |> sink(\"examples.wav\")\n","category":"page"},{"location":"#Acknowledgements-1","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Many thanks to @ssfrr for some great discussions during this PR, and related issues on the SampledSignals package. Those interactions definitely influenced my final design here.","category":"page"}]
}
